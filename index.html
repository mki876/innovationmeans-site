<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>InnoSketch ‚Äî Offline Mind-Mapping for Young Innovators</title>
<meta name="description" content="InnoSketch is a single-file, offline mind-mapping tool that helps young innovators visualize and structure ideas using a canvas, with local save/load and export." />

<style>
/* =========================
   InnoSketch ‚Äî Offline-First
   Clean, youthful UI (pastels)
   Accessible, responsive, no CDN
   ========================= */

/* CSS Variables for themes */
:root{
  --bg: #f7fafe;           /* pastel blue-ish */
  --bg-2:#eef5ff;          /* toolbar */
  --ink:#263238;           /* dark slate text */
  --accent:#8ecae6;        /* light aqua */
  --accent-2:#90e0ef;      /* brighter aqua */
  --accent-3:#ffd6a5;      /* soft peach */
  --ok:#4caf50;            /* green */
  --warn:#ff9800;          /* orange */
  --danger:#ef5350;        /* red */
  --shadow: rgba(38, 50, 56, .08);
  --grid:#dbeafe;
  --dash:#90a4ae;
  --focus:#3f51b5;
}

/* High-contrast mode overrides (toggleable) */
:root.hc{
  --bg:#000;
  --bg-2:#111;
  --ink:#fff;
  --accent:#fff176;
  --accent-2:#ffee58;
  --accent-3:#ffb74d;
  --grid:#333;
  --dash:#bbb;
  --focus:#fff;
  --shadow: rgba(255,255,255, .25);
}

*{ box-sizing:border-box; }

html, body{
  margin:0;
  height:100%;
  background:var(--bg);
  color:var(--ink);
  font-family: Arial, "Helvetica Neue", Helvetica, sans-serif;
}

/* Top toolbar */
#toolbar{
  position:fixed;
  inset:0 0 auto 0;
  display:flex;
  gap:.5rem;
  align-items:center;
  padding:.5rem;
  background: var(--bg-2);
  box-shadow: 0 2px 12px var(--shadow);
  z-index:10;
  flex-wrap: wrap;
}
.group{
  display:flex;
  align-items:center;
  gap:.25rem;
  padding:.25rem .5rem;
  border-radius: 12px;
  background:#ffffffaa;
  backdrop-filter: blur(2px);
  border:1px solid #ffffff40;
}
label.small{font-size:.8rem; opacity:.9;}
button, select, input[type="color"], input[type="text"]{
  font: inherit;
  border:1px solid #cfd8dc;
  background:white;
  color:var(--ink);
  border-radius:10px;
  padding:.45rem .65rem;
  cursor:pointer;
  outline:none;
}
button{
  transition: transform .06s ease, box-shadow .2s ease, background .2s ease;
  box-shadow: 0 1px 0 #00000005, 0 1px 8px var(--shadow);
}
button:hover{ transform: translateY(-1px); }
button:active{ transform: translateY(0); }
button.primary{ background: linear-gradient(180deg, var(--accent-2), var(--accent)); border-color: #7ec3db; }
button.warn{ background: linear-gradient(180deg, #ffecb3, #ffe082); border-color:#ffca28; }
button.ok{ background: linear-gradient(180deg, #c8e6c9, #a5d6a7); border-color:#66bb6a; }
button.ghost{ background:#fff; }
button.toggle[aria-pressed="true"]{ outline:2px solid var(--focus); }

input[type="text"]{
  min-width:10rem;
}
#iconPicker{
  width:3.5rem;
}

kbd{
  font-size:.8rem;
  background:#00000010;
  padding:.1rem .35rem;
  border-radius:.3rem;
  border:1px solid #00000020;
}

/* Canvas wraps full viewport (minus toolbar + footer) */
#stageWrap{
  position:absolute;
  top:3.75rem; /* approx toolbar height */
  left:0; right:0;
  bottom:2.5rem; /* footer */
}
#canvas{
  width:100%;
  height:100%;
  display:block;
  background:
    linear-gradient(#0000, #0000) /* placeholder */,
    repeating-linear-gradient(0deg, var(--grid) 0 1px, #0000 1px 32px),
    repeating-linear-gradient(90deg, var(--grid) 0 1px, #0000 1px 32px);
  cursor: grab;
}
#canvas:active{ cursor:grabbing; }

/* Floating status pill */
#status{
  position:fixed;
  right:.75rem;
  top: calc(3.75rem + .75rem);
  background:#ffffffd8;
  padding:.35rem .6rem;
  border-radius: .75rem;
  box-shadow: 0 2px 10px var(--shadow);
  font-size:.85rem;
}

/* Footer */
footer{
  position:fixed;
  inset:auto 0 0 0;
  padding:.35rem .75rem;
  background: var(--bg-2);
  font-size:.85rem;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:.75rem;
  border-top:1px solid #e3f2fd;
}

/* Inline node editor */
#inlineEditor{
  position:absolute;
  display:none;
  z-index:20;
}
#inlineEditor input{
  font: inherit;
  padding:.35rem .5rem;
  border-radius:.4rem;
  border:1px solid #90a4ae;
  min-width: 12rem;
  background:#fffefc;
  box-shadow: 0 4px 12px var(--shadow);
}

/* Help modal (quick tips) */
#help{
  position:fixed;
  right:.75rem;
  bottom: calc(2.5rem + .75rem);
  max-width: 22rem;
  background:#ffffffdd;
  border:1px solid #eceff1;
  border-radius:.75rem;
  box-shadow:0 10px 30px var(--shadow);
  padding:.75rem;
  font-size:.9rem;
}

/* Mobile adjustments */
@media (max-width: 768px){
  #toolbar{ gap:.35rem; }
  input[type="text"]{ min-width:8rem; }
}

</style>
</head>
<body>

<!-- =========================
     Toolbar
     ========================= -->
<div id="toolbar" role="toolbar" aria-label="InnoSketch Toolbar">
  <div class="group" aria-label="Add & Edit">
    <button id="btnAdd" class="primary" aria-label="Add Node (N)" title="Add Node (N)">
      ‚ûï Add Node
    </button>
    <input id="titleTxt" type="text" aria-label="Node text" placeholder="Idea title‚Ä¶" />
    <input id="colorPick" type="color" aria-label="Node color" value="#ffffff" title="Node Color"/>
    <select id="shapePick" aria-label="Node shape">
      <option value="rect">Rectangle</option>
      <option value="circle">Circle</option>
    </select>
    <select id="iconPicker" aria-label="Emoji icon">
      <!-- populated in JS -->
    </select>
  </div>

  <div class="group" aria-label="Connect & Cluster">
    <button id="btnConnect" class="ghost toggle" aria-pressed="false" aria-label="Connect Mode (C)">
      üîó Connect
    </button>
    <button id="btnCluster" class="ghost" aria-label="Add Cluster Area (G)">
      üü¶ Cluster
    </button>
  </div>

  <div class="group" aria-label="View">
    <button id="btnResetView" class="ghost" aria-label="Reset zoom/pan">
      üîÑ Reset View
    </button>
    <button id="btnContrast" class="ghost" aria-label="Toggle High Contrast (H)">
      üåì Contrast
    </button>
  </div>

  <div class="group" aria-label="Export">
    <button id="btnPNG" class="ok" aria-label="Export PNG">
      üñºÔ∏è PNG
    </button>
    <button id="btnPDF" class="ok" aria-label="Export PDF">
      üìÑ PDF
    </button>
    <button id="btnSave" class="warn" aria-label="Save .innos">
      üíæ Save
    </button>
    <label class="small" for="fileLoad" aria-label="Load .innos file">Load</label>
    <input id="fileLoad" type="file" accept=".innos,application/json" aria-label="Load .innos file" />
  </div>

  <div class="group" aria-label="Help">
    <span>Shortcuts:
      <kbd>N</kbd> new &nbsp; <kbd>C</kbd> connect &nbsp; <kbd>G</kbd> cluster &nbsp; <kbd>H</kbd> contrast &nbsp; <kbd>Del</kbd> delete
    </span>
  </div>
</div>

<!-- Status pill -->
<div id="status" aria-live="polite">Ready</div>

<!-- Canvas Stage -->
<div id="stageWrap">
  <canvas id="canvas" aria-label="Mind map canvas" role="application"></canvas>
  <!-- Inline node editor -->
  <div id="inlineEditor"><input type="text" aria-label="Edit node text"/></div>
</div>

<!-- Quick tips -->
<aside id="help" aria-label="Quick Tips">
  <strong>InnoSketch Tips</strong>
  <ul>
    <li>Drag nodes to position ‚Äî they snap to grid.</li>
    <li>Use <em>Connect</em> mode (üîó) then click two nodes to draw an arrow.</li>
    <li>Use <em>Cluster</em> to add dashed areas for grouping.</li>
    <li>Pan with background drag (or hold <kbd>Space</kbd>), zoom with mouse wheel/pinch.</li>
  </ul>
</aside>

<!-- Footer (Ethical/Impact Notes) -->
<footer>
  <div>
    <strong>Powered by Innovation World ‚Äî Innovate Offline!</strong>
    ‚Ä¢ No data collection. All maps stay on your device.
  </div>
  <div>
    Collaboration idea: share <code>.innos</code> files via USB/email & open locally.
  </div>
</footer>

<script>
/* ===========================================
   InnoSketch ‚Äî Single-file Offline Mind Mapper
   Pure Canvas; localStorage autosave
   Size-conscious, no external dependencies
   =========================================== */

/* -----------------------------
   Constants & State
------------------------------ */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { alpha: false });
const DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
const statusEl = document.getElementById('status');
const inlineEditor = document.querySelector('#inlineEditor input');
const inlineWrap = document.getElementById('inlineEditor');

const EMOJI = ['','üí°','‚öôÔ∏è','üåç','üß™','üéØ','ü§ù','üõ†Ô∏è','üìö','üìà','üî¨','‚ôªÔ∏è','üß†','‚ú®'];
const iconPicker = document.getElementById('iconPicker');
EMOJI.forEach(e => {
  const op = document.createElement('option');
  op.value = e; op.textContent = e || '‚Äî';
  iconPicker.appendChild(op);
});

let world = {
  nodes: [],         // {id,x,y,w,h,text,fill,shape,icon}
  edges: [],         // {fromId,toId,curved?:bool}
  clusters: [],      // {id,x,y,w,h,label}
  nextId: 1,
  view: { x:0, y:0, scale:1 } // pan/zoom
};

let ui = {
  mode: 'select', // 'select' | 'connect' | 'cluster' | 'pan'
  hoverNodeId: null,
  activeNodeId: null,
  connectFirstId: null,
  draggingNodeId: null,
  draggingClusterId: null,
  dragOffset: {x:0,y:0},
  isPanning: false,
  lastMouse: {x:0,y:0},
  snap: 16,
  animPulse: 0,
  hoverHandle: null // for cluster resize
};

/* -----------------------------
   Resize Canvas
------------------------------ */
function resizeCanvas(){
  const rect = canvas.getBoundingClientRect();
  canvas.width = Math.max(1, rect.width * DPR);
  canvas.height= Math.max(1, rect.height* DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0); // draw in CSS pixels
  draw();
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

/* -----------------------------
   Utility (view transforms)
------------------------------ */
function toWorld(pt){
  const s = world.view.scale;
  return { x: (pt.x - world.view.x)/s, y: (pt.y - world.view.y)/s };
}
function toScreen(pt){
  const s = world.view.scale;
  return { x: pt.x*s + world.view.x, y: pt.y*s + world.view.y };
}
function snap(v){ return Math.round(v / ui.snap) * ui.snap; }
function setStatus(msg){ statusEl.textContent = msg; }

/* -----------------------------
   Creation Helpers
------------------------------ */
function addNode(opts={}){
  const id = world.nextId++;
  const node = {
    id,
    x: snap((Math.random()*400)+100),
    y: snap((Math.random()*200)+100),
    w: 160, h: 64,
    text: (document.getElementById('titleTxt').value || 'New Idea'),
    fill: (document.getElementById('colorPick').value || '#ffffff'),
    shape: (document.getElementById('shapePick').value || 'rect'),
    icon: (iconPicker.value || ''),
  };
  Object.assign(node, opts);
  world.nodes.push(node);
  autosave();
  setStatus('Node added');
  draw();
  return node.id;
}

function addCluster(){
  const id = world.nextId++;
  world.clusters.push({
    id, x: snap(80), y: snap(80), w: 320, h: 200, label: 'Cluster'
  });
  autosave(); draw();
  setStatus('Cluster created');
}

function findNodeAt(worldPt){
  for (let i = world.nodes.length-1; i>=0; i--){
    const n = world.nodes[i];
    if (n.shape==='rect'){
      if (worldPt.x>=n.x && worldPt.x<=n.x+n.w && worldPt.y>=n.y && worldPt.y<=n.y+n.h){
        return n;
      }
    } else {
      const cx = n.x + n.w/2, cy = n.y + n.h/2;
      const rx = n.w/2, ry = n.h/2;
      const dx = (worldPt.x - cx)/rx, dy = (worldPt.y - cy)/ry;
      if (dx*dx + dy*dy <= 1) return n;
    }
  }
  return null;
}

function findClusterAt(worldPt){
  for (let i = world.clusters.length-1; i>=0; i--){
    const c = world.clusters[i];
    if (worldPt.x>=c.x && worldPt.x<=c.x+c.w && worldPt.y>=c.y && worldPt.y<=c.y+c.h){
      return c;
    }
  }
  return null;
}

function removeSelected(){
  if (ui.activeNodeId){
    const id = ui.activeNodeId;
    world.nodes = world.nodes.filter(n=>n.id!==id);
    world.edges = world.edges.filter(e=>e.fromId!==id && e.toId!==id);
    ui.activeNodeId=null;
    setStatus('Node deleted');
  } else if (ui.draggingClusterId){
    world.clusters = world.clusters.filter(c=>c.id!==ui.draggingClusterId);
    ui.draggingClusterId = null;
    setStatus('Cluster deleted');
  }
  autosave(); draw();
}

/* -----------------------------
   Drawing
------------------------------ */
function drawGrid(){
  // Grid handled by CSS background; optional axes or origin crosshairs here
}

function drawClusters(){
  ctx.save();
  ctx.lineWidth = 2;
  ctx.setLineDash([8,6]);
  ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--dash').trim();
  ctx.fillStyle = 'transparent';
  for (const c of world.clusters){
    const s = toScreen({x:c.x, y:c.y});
    const w = c.w*world.view.scale, h = c.h*world.view.scale;
    roundRect(ctx, s.x, s.y, w, h, 12);
    ctx.stroke();

    // label
    ctx.setLineDash([]);
    ctx.font = 'bold 14px Arial';
    ctx.fillStyle = ctx.strokeStyle;
    ctx.fillText(c.label, s.x+10, s.y+20);
    ctx.setLineDash([8,6]);
  }
  ctx.restore();
}

function drawNodes(){
  for (const n of world.nodes){
    const scr = toScreen({x:n.x, y:n.y});
    const w = n.w*world.view.scale, h = n.h*world.view.scale;

    // Shadow/glow if active
    if (ui.activeNodeId===n.id){
      ctx.save();
      ctx.shadowColor = 'rgba(63,81,181,.6)';
      ctx.shadowBlur = 18;
      ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0;
      ctx.fillStyle = n.fill;
      if (n.shape==='rect') roundRect(ctx, scr.x, scr.y, w, h, 10);
      else ellipseRect(ctx, scr.x, scr.y, w, h);
      ctx.fill();
      ctx.restore();
    }

    // Node fill
    ctx.fillStyle = n.fill || '#fff';
    ctx.strokeStyle = '#90a4ae';
    ctx.lineWidth = 1.5;
    if (n.shape==='rect') { roundRect(ctx, scr.x, scr.y, w, h, 10); }
    else { ellipseRect(ctx, scr.x, scr.y, w, h); }
    ctx.fill();
    ctx.stroke();

    // Icon + Text
    const pad = 10*world.view.scale;
    ctx.fillStyle = '#263238';
    ctx.font = `${Math.max(12, 13*world.view.scale)}px Arial`;
    const icon = n.icon || '';
    if (icon){
      ctx.fillText(icon, scr.x+pad, scr.y+Math.min(h-8, 22*world.view.scale));
    }
    const textX = scr.x+pad + (icon? 20*world.view.scale : 0);
    wrapText(ctx, n.text, textX, scr.y+Math.min(h-12, 22*world.view.scale), w-pad*2, Math.max(14, 14*world.view.scale));
  }
}

function drawEdges(){
  ctx.save();
  ctx.lineWidth = 2;
  ctx.strokeStyle = '#607d8b';
  ctx.fillStyle = ctx.strokeStyle;
  for (const e of world.edges){
    const a = world.nodes.find(n=>n.id===e.fromId);
    const b = world.nodes.find(n=>n.id===e.toId);
    if (!a || !b) continue;
    const A = toScreen(centerOf(a));
    const B = toScreen(centerOf(b));
    if (e.curved){
      const mx = (A.x+B.x)/2, my=(A.y+B.y)/2;
      const dx = B.x-A.x, dy=B.y-A.y;
      const nx = -dy*.15, ny = dx*.15; // curve normal
      ctx.beginPath();
      ctx.moveTo(A.x, A.y);
      ctx.quadraticCurveTo(mx+nx, my+ny, B.x, B.y);
      ctx.stroke();
      drawArrowhead(B.x, B.y, Math.atan2((my+ny)-B.y,(mx+nx)-B.x));
    } else {
      ctx.beginPath();
      ctx.moveTo(A.x, A.y);
      ctx.lineTo(B.x, B.y);
      ctx.stroke();
      drawArrowhead(B.x, B.y, Math.atan2(A.y-B.y,A.x-B.x));
    }
  }
  ctx.restore();
}

function draw(){
  ctx.save();
  ctx.clearRect(0,0,canvas.width, canvas.height);
  // (Canvas background grid is CSS)

  drawClusters();
  drawEdges();
  drawNodes();

  // Selection ring
  if (ui.activeNodeId){
    const n = world.nodes.find(n=>n.id===ui.activeNodeId);
    if (n){
      const s = toScreen({x:n.x, y:n.y});
      ctx.save();
      ctx.setLineDash([5,5]);
      ctx.strokeStyle = '#3f51b5';
      ctx.lineWidth = 2;
      if (n.shape==='rect') roundRect(ctx, s.x-6, s.y-6, n.w*world.view.scale+12, n.h*world.view.scale+12, 12);
      else ellipseRect(ctx, s.x-6, s.y-6, n.w*world.view.scale+12, n.h*world.view.scale+12);
      ctx.stroke();
      ctx.restore();
    }
  }

  ctx.restore();
}

/* Helpers */
function roundRect(c,x,y,w,h,r){
  c.beginPath();
  c.moveTo(x+r,y);
  c.arcTo(x+w,y,x+w,y+h,r);
  c.arcTo(x+w,y+h,x,y+h,r);
  c.arcTo(x,y+h,x,y,r);
  c.arcTo(x,y,x+w,y,r);
  c.closePath();
}
function ellipseRect(c,x,y,w,h){
  c.beginPath();
  c.ellipse(x+w/2, y+h/2, w/2, h/2, 0, 0, Math.PI*2);
  c.closePath();
}
function centerOf(n){ return { x:n.x + n.w/2, y:n.y+n.h/2 }; }

function drawArrowhead(x,y,angle){
  const size = 8*world.view.scale;
  ctx.save();
  ctx.translate(x,y);
  ctx.rotate(angle);
  ctx.beginPath();
  ctx.moveTo(0,0);
  ctx.lineTo(-size, size*0.6);
  ctx.lineTo(-size, -size*0.6);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

function wrapText(c, text, x, y, maxWidth, lineHeight){
  const words = String(text||'').split(/\s+/);
  let line = '', yy=y;
  for (let w of words){
    const t = line ? line + ' ' + w : w;
    if (c.measureText(t).width > maxWidth && line){
      c.fillText(line, x, yy); yy += lineHeight;
      line = w;
    } else line = t;
  }
  if (line) c.fillText(line, x, yy);
}

/* -----------------------------
   Mouse & Touch Interactions
------------------------------ */
function screenPoint(evt){
  if (evt.touches && evt.touches[0]){
    return { x: evt.touches[0].clientX, y: evt.touches[0].clientY };
  }
  return { x: evt.clientX, y: evt.clientY };
}

canvas.addEventListener('mousedown', onPointerDown);
canvas.addEventListener('touchstart', onPointerDown, {passive:false});
window.addEventListener('mousemove', onPointerMove, {passive:false});
window.addEventListener('touchmove', onPointerMove, {passive:false});
window.addEventListener('mouseup', onPointerUp);
window.addEventListener('touchend', onPointerUp);

function onPointerDown(e){
  e.preventDefault();
  const scr = screenPoint(e);
  ui.lastMouse = scr;

  const worldPt = toWorld(scr);

  // Spacebar or right click => pan
  if (e.button===2 || ui.mode==='pan' || e.shiftKey){
    ui.isPanning = true; return;
  }

  // Resize handle for clusters (bottom-right corner)
  const hitCluster = findClusterAt(worldPt);
  if (hitCluster && nearHandle(worldPt, hitCluster)){
    ui.hoverHandle = { id: hitCluster.id, type:'cluster-resize' };
    ui.draggingClusterId = hitCluster.id;
    return;
  }

  // Hit test nodes
  const node = findNodeAt(worldPt);
  if (node){
    if (ui.mode==='connect'){
      if (!ui.connectFirstId){
        ui.connectFirstId = node.id;
        ui.activeNodeId = node.id;
        setStatus('Select a target node to connect');
      } else if (ui.connectFirstId !== node.id){
        world.edges.push({fromId: ui.connectFirstId, toId: node.id, curved: false});
        ui.connectFirstId = null;
        setStatus('Connected nodes');
        autosave(); draw();
      }
      return;
    }
    // Dragging
    ui.draggingNodeId = node.id;
    ui.activeNodeId = node.id;
    ui.dragOffset = { x: worldPt.x - node.x, y: worldPt.y - node.y };
    // Inline edit on double-click handled by dblclick
    draw();
  } else if (hitCluster){
    ui.draggingClusterId = hitCluster.id;
    ui.dragOffset = { x: worldPt.x - hitCluster.x, y: worldPt.y - hitCluster.y };
    ui.activeNodeId = null;
  } else {
    // background => start panning
    ui.isPanning = true;
    ui.activeNodeId = null;
  }
}

canvas.addEventListener('dblclick', (e)=>{
  const scr = screenPoint(e);
  const wpt = toWorld(scr);
  const node = findNodeAt(wpt);
  if (!node) return;

  // Position inline editor above node
  const s = toScreen({x:node.x, y:node.y});
  inlineWrap.style.left = (s.x + 8) + 'px';
  inlineWrap.style.top  = (s.y - 8) + 'px';
  inlineWrap.style.display = 'block';
  inlineEditor.value = node.text;
  inlineEditor.focus();
  inlineEditor.onblur = ()=>{
    node.text = inlineEditor.value || node.text;
    inlineWrap.style.display='none';
    autosave(); draw();
  };
  inlineEditor.onkeydown=(ev)=>{
    if (ev.key==='Enter'){ inlineEditor.blur(); }
    if (ev.key==='Escape'){ inlineWrap.style.display='none'; }
  };
});

function onPointerMove(e){
  const scr = screenPoint(e);
  const wpt = toWorld(scr);
  if (ui.isPanning){
    world.view.x += (scr.x - ui.lastMouse.x);
    world.view.y += (scr.y - ui.lastMouse.y);
    ui.lastMouse = scr;
    draw(); return;
  }

  // Resize cluster
  if (ui.hoverHandle && ui.hoverHandle.type==='cluster-resize' && ui.draggingClusterId){
    const c = world.clusters.find(c=>c.id===ui.draggingClusterId);
    if (c){
      const nx = Math.max(snap(120), snap(wpt.x - c.x));
      const ny = Math.max(snap(80),  snap(wpt.y - c.y));
      c.w = nx; c.h = ny;
      draw();
    }
    return;
  }

  if (ui.draggingNodeId){
    const node = world.nodes.find(n=>n.id===ui.draggingNodeId);
    if (node){
      node.x = snap(wpt.x - ui.dragOffset.x);
      node.y = snap(wpt.y - ui.dragOffset.y);
      draw();
    }
    return;
  }
  if (ui.draggingClusterId){
    const c = world.clusters.find(c=>c.id===ui.draggingClusterId);
    if (c){
      c.x = snap(wpt.x - ui.dragOffset.x);
      c.y = snap(wpt.y - ui.dragOffset.y);
      draw();
    }
    return;
  }
}

function onPointerUp(){
  if (ui.isPanning){ ui.isPanning=false; autosave(); }
  if (ui.draggingNodeId){ ui.draggingNodeId=null; autosave(); }
  if (ui.draggingClusterId){ ui.draggingClusterId=null; ui.hoverHandle=null; autosave(); }
}

canvas.addEventListener('contextmenu', e=>e.preventDefault()); // disable default right-click

/* Pan with Space key */
window.addEventListener('keydown', (e)=>{
  if (e.code==='Space' && !ui.isPanning){ ui.mode='pan'; }
});
window.addEventListener('keyup', (e)=>{
  if (e.code==='Space' && ui.mode==='pan'){ ui.mode='select'; }
});

/* Zoom (wheel) */
canvas.addEventListener('wheel', (e)=>{
  const delta = -Math.sign(e.deltaY) * 0.1;
  const prevScale = world.view.scale;
  const next = Math.min(3, Math.max(0.4, prevScale + delta));
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left, my = e.clientY - rect.top;

  // Zoom about mouse
  const wx = (mx - world.view.x)/prevScale;
  const wy = (my - world.view.y)/prevScale;
  world.view.x = mx - wx*next;
  world.view.y = my - wy*next;
  world.view.scale = next;
  draw();
}, {passive:true});

function nearHandle(pt, cluster){
  const br = { x: cluster.x+cluster.w, y: cluster.y+cluster.h };
  return (Math.hypot(pt.x-br.x, pt.y-br.y) < 16);
}

/* -----------------------------
   Buttons & Shortcuts
------------------------------ */
document.getElementById('btnAdd').addEventListener('click', ()=> addNode());

document.getElementById('btnCluster').addEventListener('click', addCluster);

const btnConnect = document.getElementById('btnConnect');
btnConnect.addEventListener('click', ()=>{
  const pressed = btnConnect.getAttribute('aria-pressed')==='true';
  btnConnect.setAttribute('aria-pressed', String(!pressed));
  ui.mode = pressed ? 'select' : 'connect';
  ui.connectFirstId = null;
  setStatus(ui.mode==='connect' ? 'Connect mode ON' : 'Connect mode OFF');
});

document.getElementById('btnResetView').addEventListener('click', ()=>{
  world.view = { x:0, y:0, scale:1 };
  draw();
});

document.getElementById('btnContrast').addEventListener('click', ()=>{
  document.documentElement.classList.toggle('hc');
  draw();
});

document.getElementById('btnPNG').addEventListener('click', exportPNG);
document.getElementById('btnPDF').addEventListener('click', exportPDF);

document.getElementById('btnSave').addEventListener('click', saveInnos);
document.getElementById('fileLoad').addEventListener('change', loadInnos);

/* Keyboard */
window.addEventListener('keydown', (e)=>{
  if (e.target === inlineEditor) return;
  if (e.key==='n' || e.key==='N'){ addNode(); }
  if (e.key==='c' || e.key==='C'){ btnConnect.click(); }
  if (e.key==='g' || e.key==='G'){ addCluster(); }
  if (e.key==='h' || e.key==='H'){ document.getElementById('btnContrast').click(); }
  if (e.key==='Delete' || e.key==='Backspace'){ removeSelected(); }
});

/* -----------------------------
   Export: PNG
------------------------------ */
function exportPNG(){
  // Render at current DPR for crispness
  const url = canvas.toDataURL('image/png');
  downloadURL(url, 'InnoSketch.png');
  setStatus('Exported PNG');
}

/* -----------------------------
   Export: PDF (Minimal single-page generator)
   Note: To keep file under 500KB and avoid CDNs, we include a tiny
   custom PDF creator that embeds the canvas as a JPEG on an A4 page.
------------------------------ */
function exportPDF(){
  // Create high-quality JPEG from current canvas
  const jpgUrl = canvas.toDataURL('image/jpeg', 0.92);

  // A4 points (72 dpi): 595 x 842
  const pdf = createSimplePDFWithJPEG(jpgUrl, 595, 842, /*fit*/ true);
  const blob = new Blob([pdf], {type:'application/pdf'});
  const url = URL.createObjectURL(blob);
  downloadURL(url, 'InnoSketch.pdf');
  setStatus('Exported PDF');
}

/* Minimal PDF builder (single page with a JPEG) */
function createSimplePDFWithJPEG(jpegDataURL, pageW, pageH, fit){
  // Strip header
  const b64 = jpegDataURL.split(',')[1];
  const bin = atob(b64);
  const imgBytes = new Uint8Array(bin.length);
  for (let i=0;i<bin.length;i++) imgBytes[i]=bin.charCodeAt(i);

  const imgW = canvas.width / DPR;
  const imgH = canvas.height / DPR;

  let drawW = imgW, drawH = imgH, x=0, y=0;
  if (fit){
    const scale = Math.min(pageW/imgW, pageH/imgH);
    drawW = Math.floor(imgW*scale);
    drawH = Math.floor(imgH*scale);
    x = Math.floor((pageW-drawW)/2);
    y = Math.floor((pageH-drawH)/2);
  }

  // PDF objects
  const objs = [];
  const header = `%PDF-1.4\n`;
  function addObj(str){ objs.push(str); return objs.length; }

  const imgObjNum = addObj(
    `<< /Type /XObject /Subtype /Image /Width ${drawW} /Height ${drawH} /ColorSpace /DeviceRGB /BitsPerComponent 8 /Filter /DCTDecode /Length ${imgBytes.length} >>\nstream\n` +
    imgBytesToLatin1(imgBytes) + `\nendstream`
  );

  const resourcesNum = addObj(`<< /XObject << /Im0 ${imgObjNum} 0 R >> >>`);

  // content stream: draw image to page size using cm matrix
  const contentStream = [
    'q',
    `${drawW} 0 0 ${drawH} ${x} ${y} cm`,
    '/Im0 Do',
    'Q'
  ].join('\n');
  const contentNum = addObj(`<< /Length ${contentStream.length} >>\nstream\n${contentStream}\nendstream`);

  const pageNum = addObj(
    `<< /Type /Page /Parent 2 0 R /Resources ${resourcesNum} 0 R /MediaBox [0 0 ${pageW} ${pageH}] /Contents ${contentNum} 0 R >>`
  );

  const pagesNum = addObj(
    `<< /Type /Pages /Count 1 /Kids [ ${pageNum} 0 R ] >>`
  );

  const catalogNum = addObj(
    `<< /Type /Catalog /Pages ${pagesNum} 0 R >>`
  );

  // xref table
  let offsets = []; let pos = header.length;
  function offsetOf(s){ const o=pos; pos+= (s.length+(`\n`).length); return o; }
  const body = objs.map((s,i)=>`${i+1} 0 obj\n${s}\nendobj`).map(s=>{ const off=offsetOf(s); offsets.push(off); return s; }).join('\n');

  const xrefPos = pos;
  let xref = `xref\n0 ${objs.length+1}\n0000000000 65535 f \n`;
  for (let o of offsets){
    xref += (String(o).padStart(10,'0') + ' 00000 n \n');
  }
  const trailer =
    `trailer\n<< /Size ${objs.length+1} /Root ${catalogNum} 0 R >>\nstartxref\n${xrefPos}\n%%EOF`;

  const pdfStr = header + body + '\n' + xref + trailer;
  return new TextEncoder().encode(pdfStr);
}
function imgBytesToLatin1(u8){
  let out = '';
  for (let i=0;i<u8.length;i++) out += String.fromCharCode(u8[i]);
  return out;
}

/* -----------------------------
   Save / Load (.innos) + Autosave
------------------------------ */
function serialize(){
  return {
    nodes: world.nodes,
    edges: world.edges,
    clusters: world.clusters,
    nextId: world.nextId,
    view: world.view
  };
}
function deserialize(data){
  world.nodes = data.nodes||[];
  world.edges = data.edges||[];
  world.clusters = data.clusters||[];
  world.nextId = data.nextId||1;
  world.view = data.view||{x:0,y:0,scale:1};
  draw();
}
function autosave(){
  try{
    localStorage.setItem('innosketch_autosave', JSON.stringify(serialize()));
    setStatus('Autosaved');
  }catch(e){ setStatus('Autosave failed (storage full?)'); }
}
(function loadAutosave(){
  try{
    const raw = localStorage.getItem('innosketch_autosave');
    if (raw){
      deserialize(JSON.parse(raw));
      setStatus('Loaded autosave');
    }
  }catch(e){}
})();

function saveInnos(){
  const blob = new Blob([JSON.stringify(serialize(), null, 2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  downloadURL(url, 'project.innos');
  setStatus('Saved .innos');
}
function loadInnos(e){
  const f = e.target.files[0];
  if (!f) return;
  const rdr = new FileReader();
  rdr.onload = ()=>{
    try{
      const data = JSON.parse(rdr.result);
      deserialize(data);
      autosave();
      setStatus('Loaded .innos');
    }catch(err){ setStatus('Invalid .innos file'); }
  };
  rdr.readAsText(f);
}

/* -----------------------------
   Download Helper
------------------------------ */
function downloadURL(url, filename){
  const a = document.createElement('a');
  a.href = url; a.download = filename;
  document.body.appendChild(a);
  a.click();
  setTimeout(()=>URL.revokeObjectURL(url), 1500);
  a.remove();
}

/* -----------------------------
   Subtle selection animation
------------------------------ */
function tick(){
  ui.animPulse = (ui.animPulse + 1) % 360;
  requestAnimationFrame(tick);
}
tick();

/* -----------------------------
   Initial Node to Guide Users
------------------------------ */
if (!world.nodes.length){
  addNode({text:'üí° Double-click to edit me!'});
}

/* Done */
draw();

</script>
</body>
</html>
